<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/1998/REC-html40-19980424/loose.dtd">
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>P</title>
<link rel="stylesheet" href="doc.css" type="text/css">
</head>
<body>

<h1>P</h1>

<dl>

<dt><a name="*PPid"><code>*PPid</code></a>
<dd>A global constant holding the process-id of the parent picolisp process, or
<code>NIL</code> if the current process is a top level process.

<pre><code>
: (println *PPid *Pid)
NIL 5286

: (unless (fork) (println *PPid *Pid) (bye))
5286 5522
</code></pre>

<dt><a name="*Pid"><code>*Pid</code></a>
<dd>A global constant holding the current process-id.

<pre><code>
: *Pid
-> 6386
: (call "ps")  # Show processes
  PID TTY          TIME CMD
 .... ...      ........ .....
 6386 pts/1    00:00:00 bin/picolisp   # <- current process
 6388 pts/1    00:00:00 ps
-> T
</code></pre>

<dt><a name="pack"><code>(pack 'any ..) -> sym</code></a>
<dd>Returns a transient symbol whose name is concatenated from all arguments
<code>any</code>. A <code>NIL</code> arguments contributes nothing to the result
string, a number is converted to a digit string, a symbol supplies the
characters of its name, and for a list its elements are taken. See also <code><a
href="refT.html#text">text</a></code> and <code><a
href="refG.html#glue">glue</a></code>.

<pre><code>
: (pack 'car " is " 1 '(" symbol " name))
-> "car is 1 symbol name"
</code></pre>

<dt><a name="pad"><code>(pad 'cnt 'num) -> sym</code></a>
<dd>Returns a transient symbol with <code>num</code> <code><a
href="refP.html#pack">pack</a></code>ed with leading '0' characters, up to a
field width of <code>cnt</code>. See also <code><a
href="refF.html#format">format</a></code> and <code><a
href="refA.html#align">align</a></code>.

<pre><code>
: (pad 5 1)
-> "00001"
: (pad 5 123456789)
-> "123456789"
</code></pre>

<dt><a name="pair"><code>(pair 'any) -> any</code></a>
<dd>Returns <code>any</code> when the argument a cons pair cell. See also
<code><a href="refA.html#atom">atom</a></code>.

<pre><code>
: (pair NIL)
-> NIL
: (pair (1 . 2))
-> (1 . 2)
: (pair (1 2 3))
-> (1 2 3)
</code></pre>

<dt><a name="part/3"><code>part/3</code></a>
<dd><a href="ref.html#pilog">Pilog</a> predicate that succeeds if the first
argument, after <code><a href="refF.html#fold">fold</a></code>ing it to a
canonical form, is a <i>substring</i> of the folded string representation of the
result of applying the <code><a href="refG.html#get">get</a></code> algorithm to
the following arguments. Typically used as filter predicate in <code><a
href="refS.html#select/3">select/3</a></code> database queries. See also
<code><a href="refS.html#sub?">sub?</a></code>, <code><a
href="refI.html#isa/2">isa/2</a></code>, <code><a
href="refS.html#same/3">same/3</a></code>, <code><a
href="refB.html#bool/3">bool/3</a></code>, <code><a
href="refR.html#range/3">range/3</a></code>, <code><a
href="refH.html#head/3">head/3</a></code>, <code><a
href="refF.html#fold/3">fold/3</a></code> and <code><a
href="refT.html#tolr/3">tolr/3</a></code>.

<pre><code>
: (?
   @Nr (1 . 5)
   @Nm "part"
   (select (@Item)
      ((nr +Item @Nr) (nm +Item @Nm))
      (range @Nr @Item nr)
      (part @Nm @Item nm) ) )
 @Nr=(1 . 5) @Nm="part" @Item={3-1}                                              @Nr=(1 . 5) @Nm="part" @Item={3-2}
-> NIL
</code></pre>

<dt><a name="pass"><code>(pass 'fun ['any ..]) -> any</code></a>
<dd>Passes to <code>fun</code> all arguments <code>any</code>, and all remaining
variable arguments (<code>@</code>) as they would be returned by <code><a
href="refR.html#rest">rest</a></code>. <code>(pass 'fun 'any)</code> is
equivalent to <code>(apply 'fun (rest) 'any)</code>. See also <code><a
href="refA.html#apply">apply</a></code>.

<pre><code>
: (de bar (A B . @)
   (println 'bar A B (rest)) )
-> bar
: (de foo (A B . @)
   (println 'foo A B)
   (pass bar 1)
   (pass bar 2) )
-> foo
: (foo 'a 'b 'c 'd 'e 'f)
foo a b
bar 1 c (d e f)
bar 2 c (d e f)
-> (d e f)
</code></pre>

<dt><a name="pat?"><code>(pat? 'any) -> pat | NIL</code></a>
<dd>Returns <code>any</code> when the argument <code>any</code> is a symbol
whose name starts with an at-mark "<code>@</code>", otherwise <code>NIL</code>.

<pre><code>
: (pat? '@)
-> @
: (pat? "@Abc")
-> "@Abc"
: (pat? "ABC")
-> NIL
: (pat? 123)
-> NIL
</code></pre>

<dt><a name="patch"><code>(patch 'lst 'any . prg) -> any</code></a>
<dd>Destructively replaces all sub-expressions of <code>lst</code>, that
<code><a href="refM.html#match">match</a></code> the pattern <code>any</code>,
by the result of the execution of <code>prg</code>. See also <code><a
href="refD.html#daemon">daemon</a></code> and <code><a
href="refR.html#redef">redef</a></code>.

<pre><code>
: (pp 'hello)
(de hello NIL
   (prinl "Hello world!") )
-> hello

: (patch hello 'prinl 'println)
-> NIL
: (pp 'hello)
(de hello NIL
   (println "Hello world!") )
-> hello

: (patch hello '(prinl @S) (fill '(println "We said: " . @S)))
-> NIL
: (hello)
We said: Hello world!
-> "Hello world!"
</code></pre>

<dt><a name="path"><code>(path 'any) -> sym</code></a>
<dd>Substitutes any leading "<code>@</code>" character in the <code>any</code>
argument with the <u>PicoLisp Home Directory</u>, as it was remembered during
interpreter startup. Optionally, the name may be preceded by a "<code>+</code>"
character (as used by <code><a href="refI.html#in">in</a></code> and <code><a
href="refO.html#out">out</a></code>). This mechanism is used internally by all
I/O functions. See also <code><a href="ref.html#invoc">Invocation</a></code>,
<code><a href="refB.html#basename">basename</a></code>. and <code><a
href="refD.html#dirname">dirname</a></code>.

<pre><code>
$ /usr/bin/picolisp /usr/lib/picolisp/lib.l
: (path "a/b/c")
-> "a/b/c"
: (path "@a/b/c")
-> "/usr/lib/picolisp/a/b/c"
: (path "+@a/b/c")
-> "+/usr/lib/picolisp/a/b/c"
</code></pre>

<dt><a name="peek"><code>(peek) -> sym</code></a>
<dd>Single character look-ahead: Returns the same character as the next call to
<code><a href="refC.html#char">char</a></code> would return. See also <code><a
href="refS.html#skip">skip</a></code>.

<pre><code>
$ cat a
# Comment
abcd
$ ./dbg
: (in "a" (list (peek) (char)))
-> ("#" "#")
</code></pre>

<dt><a name="permute/2"><code>permute/2</code></a>
<dd><a href="ref.html#pilog">Pilog</a> predicate that succeeds if the second
argument is a permutation of the list in the second argument. See also <code><a
href="refA.html#append/3">append/3</a></code>.

<pre><code>
: (? (permute (a b c) @X))
 @X=(a b c)
 @X=(a c b)
 @X=(b a c)
 @X=(b c a)
 @X=(c a b)
 @X=(c b a)
-> NIL
</code></pre>

<dt><a name="pick"><code>(pick 'fun 'lst ..) -> any</code></a>
<dd>Applies <code>fun</code> to successive elements of <code>lst</code> until
non-<code>NIL</code> is returned. Returns that value, or <code>NIL</code> if
<code>fun</code> did not return non-<code>NIL</code> for any element of
<code>lst</code>. When additional <code>lst</code> arguments are given, their
elements are also passed to <code>fun</code>. <code>(pick 'fun 'lst)</code> is
equivalent to <code>(fun (find 'fun 'lst))</code>. See also <code><a
href="refS.html#seek">seek</a></code>, <code><a
href="refF.html#find">find</a></code> and <code><a
href="refE.html#extract">extract</a></code>.

<pre><code>
: (setq A NIL  B 1  C NIL  D 2  E NIL  F 3)
-> 3
: (find val '(A B C D E))
-> B
: (pick val '(A B C D E))
-> 1
</code></pre>

<dt><a name="pilog"><code>(pilog 'lst . prg) -> any</code></a>
<dd>Evaluates a <a href="ref.html#pilog">Pilog</a> query, and executes
<code>prg</code> for each result set with all Pilog variables bound to their
matching values. See also <code><a href="refS.html#solve">solve</a></code>,
<code><a href="ref_.html#?">?</a></code>, <code><a
href="refG.html#goal">goal</a></code> and <code><a
href="refP.html#prove">prove</a></code>.

<pre><code>
: (pilog '((append @X @Y (a b c))) (println @X '- @Y))
NIL - (a b c)
(a) - (b c)
(a b) - (c)
(a b c) - NIL
-> NIL
</code></pre>

<dt><a name="pipe"><code>(pipe exe) -> cnt</code></a>
<dt><code>(pipe exe . prg) -> any</code>
<dd>Executes <code>exe</code> in a <code><a
href="refF.html#fork">fork</a></code>'ed child process (which terminates
thereafter). In the first form, <code>pipe</code> just returns a file descriptor
to read from the standard output of that process. In the second form, it opens
the standard output of that process as input channel during the execution of
<code>prg</code>. The current input channel will be saved and restored
appropriately. See also <code><a href="refI.html#ipid">ipid</a></code>, <code><a
href="refI.html#in">in</a></code>, <code><a href="refO.html#out">out</a></code>
and <code><a href="refR.html#rpc">rpc</a></code>.

<pre><code>
: (pipe                                # equivalent to 'any'
   (prinl "(a b # Comment^Jc d)")         # (child process)
   (read) )                               # (parent process)
-> (a b c d)
: (pipe                                # pipe through an external program
   (out '(tr "[a-z]" "[A-Z]")             # (child process)
      (prinl "abc def ghi") )
   (line T) )                             # (parent process)
-> "ABC DEF GHI"
</code></pre>

<dt><a name="place"><code>(place 'cnt 'lst 'any) -> lst</code></a>
<dd>Places <code>any</code> into <code>lst</code> at position <code>cnt</code>.
This is a non-destructive operation. See also <code><a
href="refI.html#insert">insert</a></code>, <code><a
href="refR.html#remove">remove</a></code>, <code><a
href="refA.html#append">append</a></code>, <code><a
href="refD.html#delete">delete</a></code> and <code><a
href="refR.html#replace">replace</a></code>.

<pre><code>
: (place 3 '(a b c d e) 777)
-> (a b 777 d e)
: (place 1 '(a b c d e) 777)
-> (777 b c d e)
: (place 9 '(a b c d e) 777)
-> (a b c d e 777)
</code></pre>

<dt><a name="poll"><code>(poll 'cnt) -> cnt | NIL</code></a>
<dd>Checks for the availability of data for reading on the file descriptor
<code>cnt</code>. See also <code><a href="refO.html#open">open</a></code>,
<code><a href="refI.html#in">in</a></code> and <code><a
href="refC.html#close">close</a></code>.

<pre><code>
: (and (poll *Fd) (in @ (read)))  # Prevent blocking
</code></pre>

<dt><a name="pool"><code>(pool ['sym1 ['lst] ['sym2] ['sym3]]) -> T</code></a>
<dd>Opens the file <code>sym1</code> as a database file in read/write mode. If
the file does not exist, it is created. A currently open database is closed.
<code>lst</code> is a list of block size scale factors (i.e. numbers),
defaulting to (2) (for a single file with a 256 byte block size). If
<code>lst</code> is given, an individual database file is opened for each item.
If <code>sym2</code> is non-<code>NIL</code>, it is opened in append-mode as an
asynchronous replication journal. If <code>sym3</code> is non-<code>NIL</code>,
it is opened for reading and appending, to be used as a synchronous transaction
log during <code><a href="refC.html#commit">commit</a></code>s. See also
<code><a href="refD.html#dbs">dbs</a></code>, <code><a
href="refD.html#*Dbs">*Dbs</a></code> and <code><a
href="refJ.html#journal">journal</a></code>.

<pre><code>
: (pool "/dev/hda2")
-> T

: *Dbs
-> (1 2 2 4)
: (pool "dbFile" *Dbs)
-> T
:
abu:~/pico  ls -l dbFile*
-rw-r--r-- 1 abu abu 256 2007-06-11 07:57 dbFile1
-rw-r--r-- 1 abu abu  13 2007-06-11 07:57 dbFile2
-rw-r--r-- 1 abu abu  13 2007-06-11 07:57 dbFile3
-rw-r--r-- 1 abu abu  13 2007-06-11 07:57 dbFile4
</code></pre>

<dt><a name="pop"><code>(pop 'var) -> any</code></a>
<dd>Pops the first element (CAR) from the stack in <code>var</code>. See also
<code><a href="refP.html#push">push</a></code>, <code><a
href="refQ.html#queue">queue</a></code>, <code><a
href="refC.html#cut">cut</a></code>, <code><a
href="refD.html#del">del</a></code> and <code><a
href="refF.html#fifo">fifo</a></code>.

<pre><code>
: (setq S '((a b c) (1 2 3)))
-> ((a b c) (1 2 3))
: (pop S)
-> a
: (pop (cdr S))
-> 1
: (pop 'S)
-> (b c)
: S
-> ((2 3))
</code></pre>

<dt><a name="port"><code>(port ['T] 'cnt|(cnt . cnt) ['var]) -> cnt</code></a>
<dd>Opens a TCP-Port <code>cnt</code> (or a UDP-Port if the first argument is
<code>T</code>), and returns a socket descriptor suitable as an argument for
<code><a href="refL.html#listen">listen</a></code> or <code><a
href="refA.html#accept">accept</a></code> (or <code><a
href="refU.html#udp">udp</a></code>, respectively). If <code>cnt</code> is zero,
some free port number is allocated. If a pair of <code>cnt</code>s is given
instead, it should be a range of numbers which are tried in turn. When
<code>var</code> is given, it is bound to the port number.

<pre><code>
: (port 0 'A)                       # Allocate free port
-> 4
: A
-> 1034                             # Got 1034
: (port (4000 . 4008) 'A)           # Try one of these ports
-> 5
: A
-> 4002
</code></pre>

<dt><a name="pp"><code>(pp 'sym) -> sym</code></a>
<dt><code>(pp 'sym 'cls) -> sym</code>
<dt><code>(pp '(sym . cls)) -> sym</code>
<dd>Pretty-prints the function or method definition of <code>sym</code>. The
output format would regenerate that same definition when read and executed. See
also <code><a href="refP.html#pretty">pretty</a></code>, <code><a
href="refD.html#debug">debug</a></code> and <code><a
href="refV.html#vi">vi</a></code>.

<pre><code>
: (pp 'tab)
(de tab (Lst . @)
   (for N Lst
      (let V (next)
         (and (gt0 N) (space (- N (length V))))
         (prin V)
         (and
            (lt0 N)
            (space (- 0 N (length V))) ) ) )
   (prinl) )
-> tab

: (pp 'has> '+Entity)
(dm has> (Var Val)
   (or
      (nor Val (get This Var))
      (has> (meta This Var) Val (get This Var)) ) )
-> has>

: (more (can 'has>) pp)
(dm (has> . +relation) (Val X)
   (and (= Val X) X) )

(dm (has> . +Fold) (Val X)
   (extra
      Val
      (if (= Val (fold Val)) (fold X) X) ) )

(dm (has> . +Entity) (Var Val)
   (or
      (nor Val (get This Var))
      (has> (meta This Var) Val (get This Var)) ) )

(dm (has> . +List) (Val X)
   (and
      Val
      (or
         (extra Val X)
         (find '((X) (extra Val X)) X) ) ) )

(dm (has> . +Bag) (Val X)
   (and
      Val
      (or (super Val X) (car (member Val X))) ) )
</code></pre>

<dt><a name="pr"><code>(pr 'any ..) -> any</code></a>
<dd>Binary print: Prints all <code>any</code> arguments to the current output
channel in encoded binary format. See also <code><a
href="refR.html#rd">rd</a></code>, <code><a
href="refT.html#tell">tell</a></code>, <code><a
href="refH.html#hear">hear</a></code>, <code><a
href="refR.html#rpc">rpc</a></code> and <code><a
href="refW.html#wr">wr</a></code>.

<pre><code>
: (out "x" (pr 7 "abc" (1 2 3) 'a))  # Print to "x"
-> a
: (hd "x")
00000000  04 0E 0E 61 62 63 01 04 02 04 04 04 06 03 05 61  ...abc.........a
-> NIL
</code></pre>

<dt><a name="prEval"><code>(prEval 'prg ['cnt]) -> any</code></a>
<dd>Executes <code>prg</code>, similar to <code><a
href="refR.html#run">run</a></code>, by evaluating all expressions in
<code>prg</code> (within the binding environment given by <code>cnt-1</code>).
As a side effect, all atomic expressions will be printed with <code><a
href="refP.html#prinl">prinl</a></code>. See also <code><a
href="refE.html#eval">eval</a></code>.

<pre><code>
: (let Prg 567
   (prEval
      '("abc" (prinl (+ 1 2 3)) Prg 987) ) )
abc
6
567
987
-> 987
</code></pre>

<dt><a name="pre?"><code>(pre? 'any1 'any2) -> any2 | NIL</code></a>
<dd>Returns <code>any2</code> when the string representation of
<code>any1</code> is a prefix of the string representation of <code>any2</code>.
See also <code><a href="refS.html#sub?">sub?</a></code>.

<pre><code>
: (pre? "abc" "abcdef")
-> "abcdef"
: (pre? "def" "abcdef")
-> NIL
: (pre? (+ 3 4) "7fach")
-> "7fach"
: (pre? NIL "abcdef")
-> "abcdef"
</code></pre>

<dt><a name="pretty"><code>(pretty 'any 'cnt)</code></a>
<dd>Pretty-prints <code>any</code>. If <code>any</code> is an atom, or a list
with a <code><a href="refS.html#size">size</a></code> not greater than 12, it is
<code><a href="refP.html#print">print</a></code>ed as is. Otherwise, only the
opening parenthesis and the CAR of the list is printed, all other elementes are
pretty-printed recursively indented by three spaces, followed by a space and the
corresponding closing parenthesis. The initial indentation level
<code>cnt</code> defaults to zero. See also <code><a
href="refP.html#pp">pp</a></code>.

<pre><code>
: (pretty '(a (b c d) (e (f (g) (h) (i)) (j (k) (l) (m))) (n o p) q))
(a
   (b c d)
   (e
      (f (g) (h) (i))
      (j (k) (l) (m)) )
   (n o p)
   q )-> ")"
</code></pre>

<dt><a name="prin"><code>(prin 'any ..) -> any</code></a>
<dd>Prints the string representation of all <code>any</code> arguments to the
current output channel. No space or newline is printed between individual items,
or after the last item. For lists, all elements are <code>prin</code>'ted
recursively. See also <code><a href="refP.html#prinl">prinl</a></code>.

<pre><code>
: (prin 'abc 123 '(a 1 b 2))
abc123a1b2-> (a 1 b 2)
</code></pre>

<dt><a name="prinl"><code>(prinl 'any ..) -> any</code></a>
<dd>Prints the string representation of all <code>any</code> arguments to the
current output channel, followed by a newline. No space or newline is printed
between individual items. For lists, all elements are <code>prin</code>'ted
recursively. See also <code><a href="refP.html#prin">prin</a></code>.

<pre><code>
: (prinl 'abc 123 '(a 1 b 2))
abc123a1b2
-> (a 1 b 2)
</code></pre>

<dt><a name="print"><code>(print 'any ..) -> any</code></a>
<dd>Prints all <code>any</code> arguments to the current output channel. If
there is more than one argument, a space is printed between successive
arguments. No space or newline is printed after the last item. See also <code><a
href="refP.html#println">println</a></code>, <code><a
href="refP.html#printsp">printsp</a></code>, <code><a
href="refS.html#sym">sym</a></code> and <code><a
href="refS.html#str">str</a></code>

<pre><code>
: (print 123)
123-> 123
: (print 1 2 3)
1 2 3-> 3
: (print '(a b c) 'def)
(a b c) def-> def
</code></pre>

<dt><a name="println"><code>(println 'any ..) -> any</code></a>
<dd>Prints all <code>any</code> arguments to the current output channel,
followed by a newline. If there is more than one argument, a space is printed
between successive arguments. See also <code><a
href="refP.html#print">print</a></code>, <code><a
href="refP.html#printsp">printsp</a></code>.

<pre><code>
: (println '(a b c) 'def)
(a b c) def
-> def
</code></pre>

<dt><a name="printsp"><code>(printsp 'any ..) -> any</code></a>
<dd>Prints all <code>any</code> arguments to the current output channel,
followed by a space. If there is more than one argument, a space is printed
between successive arguments. See also <code><a
href="refP.html#print">print</a></code>, <code><a
href="refP.html#println">println</a></code>.

<pre><code>
: (printsp '(a b c) 'def)
(a b c) def -> def
</code></pre>

<dt><a name="prior"><code>(prior 'lst1 'lst2) -> lst | NIL</code></a>
<dd>Returns the cell in <code>lst2</code> which immediately precedes the cell
<code>lst1</code>, or <code>NIL</code> if <code>lst1</code> is not found in
<code>lst2</code> or is the very first cell. <code><a
href="ref_.html#==">==</a></code> is used for comparison (pointer equality). See
also <code><a href="refO.html#offset">offset</a></code> and <code><a
href="refM.html#memq">memq</a></code>.

<pre><code>
: (setq L (1 2 3 4 5 6))
-> (1 2 3 4 5 6)
: (setq X (cdddr L))
-> (4 5 6)
: (prior X L)
-> (3 4 5 6)
</code></pre>

<dt><a name="proc"><code>(proc 'sym ..) -> T</code></a>
<dd>Shows a list of processes with command names given by the <code>sym</code>
arguments, using the system <code>ps</code> utility. See also <code><a
href="refH.html#hd">hd</a></code>.

<pre><code>
:  (proc 'picolisp)
  PID  PPID  STARTED    SZ %CPU WCHAN  CMD
 9781  8895 16:06:53  2536  0.8 select ./bin/picolisp -on *Dbg ./lib.l @ext.l @dbg.l app/main.l lib/too.l -main -go
 9884  9781 16:07:01  2540  0.0 wait     ./bin/picolisp -on *Dbg ./lib.l @ext.l @dbg.l app/main.l lib/too.l -main -go
-> T</code></pre>

<dt><a name="prog"><code>(prog . prg) -> any</code></a>
<dd>Executes <code>prg</code>, and returns the result of the last expression.
See also <code><a href="refN.html#nil">nil</a></code>, <code><a
href="refT.html#t">t</a></code>, <code><a
href="refP.html#prog1">prog1</a></code> and <code><a
href="refP.html#prog2">prog2</a></code>.

<pre><code>
: (prog (print 1) (print 2) (print 3))
123-> 3
</code></pre>

<dt><a name="prog1"><code>(prog1 'any1 . prg) -> any1</code></a>
<dd>Executes all arguments, and returns the result of the first expression
<code>any1</code>. See also <code><a href="refN.html#nil">nil</a></code>,
<code><a href="refT.html#t">t</a></code>, <code><a
href="refP.html#prog">prog</a></code> and <code><a
href="refP.html#prog2">prog2</a></code>.

<pre><code>
: (prog1 (print 1) (print 2) (print 3))
123-> 1
</code></pre>

<dt><a name="prog2"><code>(prog2 'any1 'any2 . prg) -> any2</code></a>
<dd>Executes all arguments, and returns the result of the second expression
<code>any2</code>. See also <code><a href="refN.html#nil">nil</a></code>,
<code><a href="refT.html#t">t</a></code>, <code><a
href="refP.html#prog">prog</a></code> and <code><a
href="refP.html#prog1">prog1</a></code>.

<pre><code>
: (prog2 (print 1) (print 2) (print 3))
123-> 2
</code></pre>

<dt><a name="prop"><code>(prop 'sym1|lst ['sym2|cnt ..] 'sym) -> lst|sym</code></a>
<dd>Fetches a property for a property key <code>sym</code> from a symbol. That
symbol is <code>sym1</code> (if no other arguments are given), or a symbol found
by applying the <code><a href="refG.html#get">get</a></code> algorithm to
<code>sym1|lst</code> and the following arguments. The property (the cell, not
just its value) is returned, suitable for direct (destructive) manipulations.
See also <code><a href="ref_.html#::">::</a></code>.

<pre><code>
: (put 'X 'cnt 0)
-> 0
: (prop 'X 'cnt)
-> (0 . cnt)
: (inc (prop 'X 'cnt))        # Directly manipulate the property value
-> 1
: (get 'X 'cnt)
-> 1
</code></pre>

<dt><a name="protect"><code>(protect . prg) -> any</code></a>
<dd>Executes <code>prg</code>, and returns the result of the last expression. If
a signal is received during that time, its handling will be delayed until the
execution of <code>prg</code> is completed. See also <code><a
href="refA.html#alarm">alarm</a></code>, <a href="refH.html#*Hup">*Hup</a>, <a
href="refS.html#*Sig1">*Sig[12]</a> and <code><a
href="refK.html#kill">kill</a></code>.

<pre><code>
: (protect (journal "db1.log" "db2.log"))
-> T
</code></pre>

<dt><a name="prove"><code>(prove 'lst ['lst]) -> lst</code></a>
<dd>The <a href="ref.html#pilog">Pilog</a> interpreter. Tries to prove the query
list in the first argument, and returns an association list of symbol-value
pairs, or <code>NIL</code> if not successful. The query list is modified as a
side effect, allowing subsequent calls to <code>prove</code> for further
results. The optional second argument may contain a list of symbols; in that
case the successful matches of rules defined for these symbols will be traced.
See also <code><a href="refG.html#goal">goal</a></code>, <code><a
href="ref_.html#->">-&gt</a></code> and <code><a
href="refU.html#unify">unify</a></code>.

<pre><code>
: (prove (goal '((equal 3 3))))
-> T
: (prove (goal '((equal 3 @X))))
-> ((@X . 3))
: (prove (goal '((equal 3 4))))
-> NIL
</code></pre>

<dt><a name="prune"><code>(prune ['flg])</code></a>
<dd>Optimizes memory usage by pruning in-memory leaf nodes of database trees.
Typically called repeatedly during heavy data imports. If <code>flg</code> is
non-<code>NIL</code>, further pruning will be disabled. See also <code><a
href="refL.html#lieu">lieu</a></code>.

<pre><code>
(in File1
   (while (someData)
      (new T '(+Cls1) ..)
      (at (0 . 10000) (commit) (prune)) ) )
(in File2
   (while (moreData)
      (new T '(+Cls2) ..)
      (at (0 . 10000) (commit) (prune)) ) )
(commit)
(prune T)
</code></pre>

<dt><a name="push"><code>(push 'var 'any ..) -> any</code></a>
<dd>Implements a stack using a list in <code>var</code>. The <code>any</code>
arguments are cons'ed in front of the value list. See also <code><a
href="refP.html#push1">push1</a></code>, <code><a
href="refP.html#pop">pop</a></code>, <code><a
href="refQ.html#queue">queue</a></code> and <code><a
href="refF.html#fifo">fifo</a></code>.

<pre><code>
: (push 'S 3)              # Use the VAL of 'S' as a stack
-> 3
: S
-> (3)
: (push 'S 2)
-> 2
: (push 'S 1)
-> 1
: S
-> (1 2 3)
: (push S 999)             # Now use the CAR of the list in 'S'
-> 999
: (push S 888 777)
-> 777
: S
-> ((777 888 999 . 1) 2 3)
</code></pre>

<dt><a name="push1"><code>(push1 'var 'any ..) -> any</code></a>
<dd>Maintains a unique list in <code>var</code>. Each <code>any</code> argument
is cons'ed in front of the value list only if it is not already a <code><a
href="refM.html#member">member</a></code> of that list. See also <code><a
href="refP.html#push">push</a></code>, <code><a
href="refP.html#pop">pop</a></code> and <code><a
href="refQ.html#queue">queue</a></code>.

<pre><code>
: (push1 'S 1 2 3)
-> 3
: S
-> (3 2 1)
: (push1 'S 2 4)
-> 4
: S
-> (4 3 2 1)
</code></pre>

<dt><a name="put"><code>(put 'sym1|lst ['sym2|cnt ..] 'sym|0 'any) -> any</code></a>
<dd>Stores a new value <code>any</code> for a property key <code>sym</code> (or
in the value cell for zero) in a symbol. That symbol is <code>sym1</code> (if no
other arguments are given), or a symbol found by applying the <code><a
href="refG.html#get">get</a></code> algorithm to <code>sym1|lst</code> and the
following arguments. See also <code><a href="ref_.html#=:">=:</a></code>.

<pre><code>
: (put 'X 'a 1)
-> 1
: (get 'X 'a)
-> 1
: (prop 'X 'a)
-> (1 . a)

: (setq L '(A B C))
-> (A B C)
: (setq B 'D)
-> D
: (put L 2 0 'p 5)  # Store '5' under the 'p' propery of the value of 'B'
-> 5
: (getl 'D)
-> ((5 . p))
</code></pre>

<dt><a name="put!"><code>(put! 'obj 'sym 'any) -> any</code></a>
<dd><a href="ref.html#trans">Transaction</a> wrapper function for <code><a
href="refP.html#put">put</a></code>. Note that for setting property values of
entities typically the <code><a
href="refE.html#entityMesssages">put!></a></code> message is used. See also
<code><a href="refN.html#new!">new!</a></code>, <code><a
href="refS.html#set!">set!</a></code> and <code><a
href="refI.html#inc!">inc!</a></code>.

<pre><code>
(put! Obj 'cnt 0)  # Setting a property of a non-entity object
</code></pre>

<dt><a name="putl"><code>(putl 'sym1|lst1 ['sym2|cnt ..] 'lst) -> lst</code></a>
<dd>Stores a complete new property list <code>lst</code> in a symbol. That
symbol is <code>sym1</code> (if no other arguments are given), or a symbol found
by applying the <code><a href="refG.html#get">get</a></code> algorithm to
<code>sym1|lst1</code> and the following arguments. All previously defined
properties for that symbol are lost. See also <code><a
href="refG.html#getl">getl</a></code> and <code><a
href="refM.html#maps">maps</a></code>.

<pre><code>
: (putl 'X '((123 . a) flg ("Hello" . b)))
-> ((123 . a) flg ("Hello" . b))
: (get 'X 'a)
-> 123
: (get 'X 'b)
-> "Hello"
: (get 'X 'flg)
-> T
</code></pre>

<dt><a name="pwd"><code>(pwd) -> sym</code></a>
<dd>Returns the path to the current working directory. See also <code><a
href="refD.html#dir">dir</a></code> and <code><a
href="refC.html#cd">cd</a></code>.

<pre><code>
: (pwd)
-> "/home/app/"
</code></pre>

</dl>

</body>
</html>
